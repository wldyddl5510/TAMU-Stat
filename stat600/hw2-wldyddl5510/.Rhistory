# sample K from n in X's row
M = X[sample(c(1:X_nrow), K), ]
} else if ((nrow(M) != K) || (ncol(M) != X_ncol)) { # compatibility check
# throw error
stop("Incompatibility between M and (X or K)")
}
# type casting so that we have compatibility
M = as.matrix(M)
# Implement K-means algorithm. It should stop when either (i) the centroids don't change from one iteration to the next, or (ii) the maximal number of iterations was reached, or (iii) one of the clusters has disappeared after one of the iterations (in which case the error message is returned)
# start iteration
while(numIter > 0) {
# get clusters of X's ith rows
Y = whole_min_cluster1(X, M)
# init new mean mat
new_mean = matrix(rep(NA, K * X_ncol), K, X_ncol)
for(k in 1:K) {
# indices of current cluster
curr_cluster_indices = which(Y %in% k)
num_of_curr_cluster = length(curr_cluster_indices)
# convergence condition -> disappearing cluster
if(num_of_curr_cluster == 0) {
stop("a cluster has been disappeared")
} else if(num_of_curr_cluster == 1) {
# only one element in the cluster
new_mean[k, ] = X[curr_cluster_indices, ]
} else {
# 2 or more -> vectorization
new_mean[k, ] = colMeans(X[curr_cluster_indices, ])
}
}
# check convergence condition -> cluster same
if(identical(M, new_mean)) {
break;
}
# successful updates
M <- new_mean
# one iteration
numIter <- (numIter - 1)
}
# Return the vector of assignments Y
return(Y)
}
# retrieve min dist cluster for given X: (i,j) contains dist(X_i, M_j) -> colmin = colmax(-)
whole_min_cluster1 <- function(X, M) {
# (x - y)^2 == x^2 + y^2 - 2xy
# X^2 is constant in this argmin, so we use X instead to reduce calculations
mat_dist = outer(rowSums(X), rowSums(M^2), '+') - tcrossprod(X, 2 * M)
# mat_dist = rowSums(M^2) - tcrossprod(X, 2*M)
# mimnum col == M_j for argmin given X_i
return(max.col(-mat_dist))
}
set.seed(1)
res1 = MyKmeans(X, K, M)
res2 = MyKmeans1(X, K, M)
all.equal(res1, res2)
res1
res2
?tcrossprod
res1 = MyKmeans(X, K, M)
res2 = MyKmeans1(X, K, M)
all.equal(res1, res2)
res1 = MyKmeans(X, K, M)
res2 = MyKmeans1(X, K, M)
all.equal(res1, res2)
res1 = MyKmeans(X, K, M)
res2 = MyKmeans1(X, K, M)
all.equal(res1, res2)
n1 = 5
k1 = 3
p1 = 2
X1 = matrix(seq(n1 * p1), n1, p1)
M1 = matrix(seq(k1 * p1), k1, p1)
outer(rowSums(X1), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1)
X1
M1
outer(rowSums(X1), rowSums(M1^2), '+')
tcrossprod(X1, 2 * M1)
rowSums(M1^2)
rep(rowSums(M1), 5)
(rowSums(M1)
(rowSums(M1))
outer(rowSums(X1), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1)
(rowSums(M1))
rowSums(M1)
mat_dist1 = outer(rowSums(X1), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1)
max.col(-mat_dist1)
rowSums(M1^2)
matrix(rowSums(M1^2), 5)
matrix(rep(rowSums(M1^2), n1), nrow = n1)
only_M1 = matrix(rep(rowSums(M1^2), n1), nrow = n1)
mat_dist2 = only_M1 - tcrossprod(X1, 2 * M1)
max.col(-mat_dist2)
max.col(-mat_dist1)
max.col(-mat_dist2)
only_M1
rowSums(X1)
mat_dist2 = outer(rep(0, n1), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1) - tcrossprod(X1, 2 * M1)
max.col(-mat_dist1)
max.col(-mat_dist2)
mat_dist1 = outer(rowSums(X1), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1)
mat_dist2 = outer(rowSums(X1^2), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1) - tcrossprod(X1, 2 * M1)
max.col(-mat_dist1)
max.col(-mat_dist2)
mat_dist1 = outer(rowSums(X1), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1)
mat_dist2 = outer(rowSums(X1^2), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1) - tcrossprod(X1, 2 * M1)
max.col(-mat_dist1)
max.col(-mat_dist2)
mat_dist1 = outer(rowSums(X1), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1)
mat_dist2 = outer(rowSums(X1^2), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1)
max.col(-mat_dist1)
max.col(-mat_dist2)
mat_dist2 = outer(rep(0, n1), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1)
max.col(-mat_dist1)
max.col(-mat_dist2)
mat_dist1 = outer(rowSums(X1), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1)
mat_dist2 = only_M1 - tcrossprod(X1, 2 * M1)
max.col(-mat_dist1)
max.col(-mat_dist2)
mat_dist1 = outer(rowSums(X1), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1)
mat_dist2 = outer(rep(0, n1), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1) - tcrossprod(X1, 2 * M1)
max.col(-mat_dist1)
max.col(-mat_dist2)
mat_dist1 = outer(rowSums(X1), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1)
mat_dist2 = outer(rep(0, n1), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1)
max.col(-mat_dist1)
max.col(-mat_dist2)
outer(rep(0, n1), rowSums(M1^2), '+')
matrix(rep(rowSums(M1^2), n1), nrow = n1)
only_M1 = matrix(rep(rowSums(M1^2), n1), nrow = n1, byrow = TRUE)
only_M1
mat_dist1 = outer(rowSums(X1), rowSums(M1^2), '+') - tcrossprod(X1, 2 * M1)
mat_dist2 = only_M1 - tcrossprod(X1, 2 * M1)
max.col(-mat_dist1)
max.col(-mat_dist2)
# Source the functions
source("FunctionsKmeans.R")
source("kmeanscpp.cpp")
sourceCpp("kmeanscpp.cpp")
# Use this file to create tests/debug your functions
# Header for Rcpp and RcppArmadillo
library(Rcpp)
library(RcppArmadillo)
# Source the functions
source("FunctionsKmeans.R")
sourceCpp("kmeanscpp.cpp")
sourceCpp("kmeanscpp.cpp")
sourceCpp("kmeanscpp.cpp")
sourceCpp("kmeanscpp.cpp")
library(fossil)
# actual example
n = 4000
p = 30
K = 10
X = matrix(rnorm(n * p), n, p)
M = matrix(rnorm(K * p), K, p)
MyKmeans(X, K, M)
MyKmeans_c(X, K, M)
whole_min_cluster(X, K)
whole_min_cluster(X, M)
whole_min_cluster_c(X, M)
sourceCpp("kmeanscpp.cpp")
whole_min_cluster(X, M)
whole_min_cluster_c(X, M)
sourceCpp("kmeanscpp.cpp")
whole_min_cluster(X, M)
whole_min_cluster_c(X, M)
sourceCpp("kmeanscpp.cpp")
sourceCpp("kmeanscpp.cpp")
whole_min_cluster(X, M)
whole_min_cluster_c(X, M)
whole_min_cluster_c(X, M)
sourceCpp("kmeanscpp.cpp")
sourceCpp("kmeanscpp.cpp")
whole_min_cluster(X, M)
whole_min_cluster_c(X, M, n, K)
sourceCpp("kmeanscpp.cpp")
whole_min_cluster(X, M)
whole_min_cluster_c(X, M, n, K)
?rowSums
rowSums(matrix(c(1,2,3,4), 2, 2))
colSums(matrix(c(1,2,3,4), 2, 2))
sourceCpp("kmeanscpp.cpp")
whole_min_cluster(X, M)
whole_min_cluster_c(X, M, n, K)
sourceCpp("kmeanscpp.cpp")
whole_min_cluster(X, M)
whole_min_cluster_c(X, M, n, K)
sourceCpp("kmeanscpp.cpp")
sourceCpp("kmeanscpp.cpp")
whole_min_cluster(X, M)
whole_min_cluster_c(X, M, n, K)
sourceCpp("kmeanscpp.cpp")
whole_min_cluster(X, M)
whole_min_cluster_c(X, M, n, K)
whole_min_cluster(X, M)
all.equal(whole_min_cluster(X, M), whole_min_cluster(X, M))
all.equal(whole_min_cluster(X, M), whole_min_cluster(X, M))
all.equal(whole_min_cluster(X, M), whole_min_cluster(X, M))
all.equal(whole_min_cluster(X, M), whole_min_cluster(X, M))
all.equal(whole_min_cluster(X, M), whole_min_cluster(X, M))
all.equal(whole_min_cluster(X, M), whole_min_cluster(X, M))
all.equal(whole_min_cluster(X, M), whole_min_cluster_c(X, M, n, K))
all.equal(whole_min_cluster(X, M), whole_min_cluster_c(X, M, n, K))
whole_min_cluster(X, M)
typeof(whole_min_cluster(X, M))
as.numeric(whole_min_cluster(X, M))
as.numeric(whole_min_cluster_c(X, M, n, K))
all.equal(whole_min_cluster(X, M),as.numeric(whole_min_cluster_c(X, M, n, K)))
all.equal(whole_min_cluster(X, M),as.numeric(whole_min_cluster_c(X, M, n, K)))
all.equal(whole_min_cluster(X, M),as.numeric(whole_min_cluster_c(X, M, n, K)))
all.equal(whole_min_cluster(X, M),as.numeric(whole_min_cluster_c(X, M, n, K)))
M_invalid_row = matrix(rnorm((K - 1) * p), K - 1, p)
as.numeric(whole_min_cluster_c(X, M, n, K))
all.equal(whole_min_cluster(X, M),as.numeric(whole_min_cluster_c(X, M, n, K)))
all.equal(whole_min_cluster(X, M),as.numeric(whole_min_cluster_c(X, M, n, K)))
set.seed(1)
whole_min_cluster(X, M)
as.numeric(whole_min_cluster_c(X, M, n, K))
all.equal(whole_min_cluster(X, M),as.numeric(whole_min_cluster_c(X, M, n, K)))
whole_min_cluster(X, M)
whole_min_cluster(X, M)
whole_min_cluster(X, M)
whole_min_cluster(X, M)
all.equal(whole_min_cluster(X, M),whole_min_cluster(X, M))
all.equal(whole_min_cluster(X, M),whole_min_cluster(X, M))
all.equal(whole_min_cluster(X, M),whole_min_cluster(X, M))
set.seed(1)
all.equal(whole_min_cluster(X, M),whole_min_cluster(X, M))
all.equal(whole_min_cluster(X, M),whole_min_cluster(X, M))
all.equal(whole_min_cluster(X, M),whole_min_cluster(X, M))
all.equal(whole_min_cluster(X, M),whole_min_cluster(X, M))
all.equal(whole_min_cluster(X, M),as.numeric(whole_min_cluster_c(X, M, n, K)))
all.equal(whole_min_cluster(X, M),as.numeric(whole_min_cluster_c(X, M, n, K)))
MyKmeans(X, K, M)
MyKmeans_c(X, K, M)
all.equal(MyKmeans(X, K, M), MyKmeans_c(X, K, M))
all.equal(MyKmeans(X, K, M), as.numeric(MyKmeans_c(X, K, M)))
all.equal(MyKmeans(X, K, M), as.numeric(MyKmeans_c(X, K, M)))
microbenchmark(
MyKmeans(X, K, M),
kmeans(X, M, iter.max = 100, algorithm = "Lloyd")$cluster,
MyKmeans_c(X, K, M)
times = 5
)
microbenchmark(
MyKmeans(X, K, M),
kmeans(X, M, iter.max = 100, algorithm = "Lloyd")$cluster,
MyKmeans_c(X, K, M),
times = 5
)
library(microbenchmark)
microbenchmark(
MyKmeans(X, K, M),
kmeans(X, M, iter.max = 100, algorithm = "Lloyd")$cluster,
MyKmeans_c(X, K, M),
times = 5
)
# Source the functions
source("FunctionsKmeans.R")
source("kmeans_c_wrapper.R")
microbenchmark(
MyKmeans(X, K, M),
kmeans(X, M, iter.max = 100, algorithm = "Lloyd")$cluster,
MyKmeans_wrapper(X, K, M),
times = 5
)
source("kmeans_c_wrapper.R")
microbenchmark(
MyKmeans(X, K, M),
kmeans(X, M, iter.max = 100, algorithm = "Lloyd")$cluster,
MyKmeans_wrapper(X, K, M),
times = 5
)
microbenchmark(
MyKmeans(X, K, M),
kmeans(X, M, iter.max = 100, algorithm = "Lloyd")$cluster,
MyKmeans_wrapper(X, K, M),
times = 5
)
# K == 1
MyKmeans(X, 1, M)
Rprof(gc.profiling = TRUE)
# MyKmeans(X, K, M)
MyKmeans_wrapper(X, K, M)
Rprof(NULL) # stop monitoring
summaryRprof() # see the report
Rprof(gc.profiling = TRUE)
MyKmeans(X, K, M)
MyKmeans_wrapper(X, K, M)
Rprof(NULL) # stop monitoring
summaryRprof() # see the report
# Source the functions
source("FunctionsKmeans.R")
source("kmeans_c_wrapper.R")
Rprof(gc.profiling = TRUE)
MyKmeans(X, K, M)
MyKmeans_wrapper(X, K, M)
Rprof(NULL) # stop monitoring
summaryRprof() # see the report
microbenchmark(
MyKmeans(X, K, M),
kmeans(X, M, iter.max = 100, algorithm = "Lloyd")$cluster,
MyKmeans_wrapper(X, K, M),
times = 5
)
microbenchmark(
MyKmeans(X, K, M),
kmeans(X, M, iter.max = 100, algorithm = "Lloyd")$cluster,
MyKmeans_wrapper(X, K, M),
times = 5
)
microbenchmark(
MyKmeans(X, K, M),
kmeans(X, M, iter.max = 100, algorithm = "Lloyd")$cluster,
MyKmeans_wrapper(X, K, M),
times = 5
)
#####ZIPCODE tests
# Load the ZIPCODE data
zipcode <- read.table("ZIPCODE.txt", header = F)
# Extract the true digits
Y <- zipcode[ , 1]
# Extract the data points
X <- zipcode[ , -1]
n = nrow(X)
p = ncol(X)
K = 10
nRep <- 50
rand_index = 0
cnt = 0
# iterate for 50 times
for(i in 1:nRep) {
trial <- try(y_hat <<- MyKmeans(X, K))
# skip the failed one
if(inherits(trial, "try-error")) {
next
}
cnt = cnt + 1
rand_index = rand_index + rand.index(Y, y_hat)
}
rand_index = rand_index / cnt
rand_index
cnt
nRep <- 10
rand_index = 0
cnt = 0
# iterate for 10 times
for(i in 1:nRep) {
trial <- try(y_hat <<- MyKmeans(X, K))
# skip the failed one
if(inherits(trial, "try-error")) {
next
}
cnt = cnt + 1
rand_index = rand_index + rand.index(Y, y_hat)
}
rand_index = rand_index / cnt
rand_index
cnt
rand_index_c = 0
cnt_c = 0
# iterate for 10 times
for(i in 1:nRep) {
trial <- try(y_hat <<- MyKmeans_wrapper(X, K))
# skip the failed one
if(inherits(trial, "try-error")) {
next
}
cnt_c = cnt_c + 1
rand_index_c = rand_index_c + rand.index(Y, y_hat)
}
rand_index_c = rand_index_c / cnt_c
rand_index_c
cnt_c
# Use this file to create tests/debug your functions
# Header for Rcpp and RcppArmadillo
library(Rcpp)
library(RcppArmadillo)
sourceCpp("kmeanscpp.cpp")
# actual example
n = 40
p = 20
K = 10
X = matrix(rnorm(n * p), n, p)
M = matrix(rnorm(K * p), K, p)
whole_min_cluster(X, M)
as.numeric(whole_min_cluster_c(X, M, n, K))
all.equal(whole_min_cluster(X, M),as.numeric(whole_min_cluster_c(X, M, n, K)))
M_invalid_row = matrix(rnorm((K - 1) * p), K - 1, p)
M_invalid_col = matrix(rnorm(K * (p - 1)), K, p - 1)
M_NULL = NULL
source("kmeans_c_wrapper.R")
# Source the functions
source("FunctionsKmeans.R")
whole_min_cluster(X, M)
as.numeric(whole_min_cluster_c(X, M, n, K))
microbenchmark(
MyKmeans(X, K, M),
kmeans(X, M, iter.max = 100, algorithm = "Lloyd")$cluster,
MyKmeans_wrapper(X, K, M),
times = 5
)
library(microbenchmark)
microbenchmark(
MyKmeans(X, K, M),
kmeans(X, M, iter.max = 100, algorithm = "Lloyd")$cluster,
MyKmeans_wrapper(X, K, M),
times = 5
)
microbenchmark(
MyKmeans(X, K, M),
kmeans(X, M, iter.max = 100, algorithm = "Lloyd")$cluster,
MyKmeans_wrapper(X, K, M),
times = 5
)
microbenchmark(
MyKmeans(X, K, M),
kmeans(X, M, iter.max = 100, algorithm = "Lloyd")$cluster,
MyKmeans_wrapper(X, K, M),
times = 5
)
microbenchmark(
MyKmeans(X, K),
kmeans(X, iter.max = 100, algorithm = "Lloyd")$cluster,
MyKmeans_wrapper(X, K),
times = 5
)
microbenchmark(
MyKmeans(X, K),
kmeans(X, iter.max = 100, algorithm = "Lloyd")$cluster,
MyKmeans_wrapper(X, K),
times = 5
)
microbenchmark(
MyKmeans(X, K),
MyKmeans_wrapper(X, K),
times = 5
)
# actual example
n = 4000
p = 200
K = 10
X = matrix(rnorm(n * p), n, p)
M = matrix(rnorm(K * p), K, p)
microbenchmark(
MyKmeans(X, K),
MyKmeans_wrapper(X, K),
times = 5
)
microbenchmark(
MyKmeans(X, K),
MyKmeans_wrapper(X, K),
times = 5
)
sourceCpp("kmeanscpp.cpp")
microbenchmark(
whole_min_cluster(X, M),
whole_min_cluster_c(X, M, n, k),
whole_min_cluster_c2(X, M, n, k),
times = 10
)
microbenchmark(
whole_min_cluster(X, M),
whole_min_cluster_c(X, M, n, K),
whole_min_cluster_c2(X, M, n, K),
times = 10
)
microbenchmark(
whole_min_cluster(X, M),
whole_min_cluster_c(X, M, n, K),
whole_min_cluster_c2(X, M, n, K),
times = 20
)
# Use this file to create tests/debug your functions
# Header for Rcpp and RcppArmadillo
library(Rcpp)
library(RcppArmadillo)
# Source the functions
source("FunctionsKmeans.R")
source("kmeans_c_wrapper.R")
library(fossil)
# actual example
n = 4000
p = 200
K = 10
X = matrix(rnorm(n * p), n, p)
M = matrix(rnorm(K * p), K, p)
View(MyKmeans_c)
View(MyKmeans_c)
View(MyKmeans_wrapper)
View(MyKmeans_wrapper)
all.equal(MyKmeans(X, K, M), as.numeric(MyKmeans_wrapper(X, K, M)))
MyKmeans(X, K, M)
as.numeric(MyKmeans_wrapper(X, K, M)
)
microbenchmark(
whole_min_cluster(X, M),
whole_min_cluster_c(X, M, n, K),
whole_min_cluster_c2(X, M, n, K),
times = 20
)
microbenchmark(
MyKmeans(X, K),
MyKmeans_wrapper(X, K),
times = 5
)
source("kmeans_c_wrapper.R")
microbenchmark(
MyKmeans(X, K),
MyKmeans_wrapper(X, K),
times = 5
)
